import path from 'path';
import fs from 'fs'
import _ from 'lodash'

const lockPath = path.resolve('package-lock.json')



function geFileSize(path) {
    const size = readFile(path, 0) // b
    return (size / 1024).toFixed(2) // 单位 kb
}

//遍历读取文件
function readFile(path, size) {
    let files = fs.readdirSync(path)
    files.forEach(walk)

    function walk(file) {
        let states = fs.statSync(path + '/' + file)
        if (states.isDirectory()) {
            readFile(path + '/' + file, size)
        } else {
            size += states.size
        }
    }

    return size
}

async function main() {
    const isExist = fs.existsSync(lockPath)
    if (!isExist) {
       throw new Error('请先执行 npm install 指令')
    }
    const data = fs.readFileSync(lockPath, 'utf8')
    // console.log(JSON.parse(data))
    const contents = JSON.parse(data)
    const allDeps = contents.dependencies

    // console.log(allDeps)
    const mainPack = new Map() // 'zscroller' => '0.4.8'

    // 在 common 中并不外表他就完全是外部的依赖  require 和 dep 可能同时存在
    const commonPack = new Map() // 'typedarray-to-buffer' => [ { mainPack: 'write-file-atomic', requireVersion: '^3.1.5' } ],
    const reDepsPack = new Map() // 'terser-webpack-plugin' => [{location: 'webpack/node_modules/terser-webpack-plugin', version: '1.4.5', label: 'reDeps'}],


    const setCommonPack = (requires, name, deps) => {
        Object.keys(requires).forEach(requireName => {
            if (!commonPack.has(requireName)) {
                commonPack.set(requireName, [])
            }
            if (deps && deps[requireName]) {
                return
            }
            const oldVal = commonPack.get(requireName)
            if(!oldVal.find(it=>it.label === 'common')){
                oldVal.push({
                    location: requireName,
                    version: requires[requireName],
                    label: 'common',
                    size: geFileSize(`./node_modules/${name}`)
                })
                commonPack.set(requireName, oldVal)
            }
        })
    }

    Object.keys(allDeps).forEach(name => {
        const item = allDeps[name]
        if (item.dev) {
            return
        }
        mainPack.set(name, item.version)

        if (item.requires) {
            setCommonPack(item.requires, name, item.dependencies)
        }

        if (item.dependencies) {
            Object.keys(item.dependencies).forEach(depsName => {
                const depsItem = item.dependencies[depsName]
                if (!reDepsPack.has(depsName)) {
                    reDepsPack.set(depsName, [])
                }
                const packArr = reDepsPack.get(depsName);

                packArr.push({
                    location: `${name}/node_modules/${depsName}`,
                    version: depsItem.version,
                    label: 'reDeps',
                    size: geFileSize(`./node_modules/${name}/node_modules/${depsName}`)
                })
                reDepsPack.set(depsName, packArr)
                // if (depsItem.requires) {
                //   setCommonPack(depsItem.requires, depsName)
                // }
            })
        }
    })

    // console.log(mainPack)
    // console.log(commonPack)
    // console.log(reDepsPack)

    const packs = new Map()

    reDepsPack.forEach((value, key) => {
        // console.log(key, commonPack.get(key))
        const itemArr = reDepsPack.get(key)
        if (commonPack.has(key)) {
            itemArr.push(...commonPack.get(key))
        }
        packs.set(key, itemArr)
    })
    var getRandomColor = function() {
        return '#' + ('00000' + (Math.random() * 0x1000000 << 0).toString(16)).substr(-6)
    }

    const max = 200

    const createTopSize = ()=>{
        let arr = []
        const push = (item) => {
            if(!arr.length){
                arr.push(item)
                return
            }
            for(let i =0,len=arr.length;i<len;i++){
                if(item.size >= arr[i].size){
                    arr.splice(i, 0, item)
                    break;
                }
            }
            if(arr.length === 6){
                arr.pop()
            }
        }

        return {
            length: arr.length,
            push: push,
            arr: arr,
        }
    }
    let topSizeIns = createTopSize()

    let nodes = []
    let edges = []
    packs.forEach((arr,name, index) => {
        let localSize = 0
        arr.forEach((item, itemIndex) => {
            const size = Number(item.size)
            nodes.push({
                x: Math.random() * 1000,
                y: Math.random() * 1000,
                id: item.location,
                name: item.location,
                symbolSize: size > max ? max : size,
                itemStyle: {
                    color: getRandomColor(),
                },
            })
            localSize += size
        })

        topSizeIns.push({ items: arr, size: localSize})

        const common = arr.find(it => it.label === 'common')
        if (common) {
            arr.forEach(item => {
                if (item.label === 'common') {
                    return
                }
                edges.push({
                    attributes: {},
                    size: 1,
                    source: common.location,
                    target: item.location,
                })
            })
        }
    })

    // console.log(nodes, edges, topSizeIns)
    fs.writeFileSync('deepCheck.json', `${JSON.stringify({nodes, edges, topSizeIns}, null, 2)}`, {encoding: 'utf-8'})

    // 打印 top5
    console.log(topSizeIns.arr)

}


export default main