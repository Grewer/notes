## 起因
场景一:  
当前项目经历了刀耕火种地开发, 之后接入了 cli 工具集中管理打包, 那么项目中的依赖,
和 cli 工具中的依赖重合度是多少, 并且他的的版本是否相同, 是否有冗余代码

场景二:  
项目中某一个库升级了, 他依赖了 A 库的 V3 版本, 同时当前项目依赖的是 A 库 V2版本, 这个时候打包很明显, 就会将这一个包的不同版本同时打入

由于上述的场景, 我们需要一个工具来解决这些情况

## 思考🤔

> 这些场景改如何解决, 解决的方案是什么
>

目前计划是通过 node 脚本来运行
- 检查 node_modules 或者 lock 文件中, 是否存在同一库的多个版本

- node_modules 文件层级太多, lock 文件是他的一层映射, 考虑从这里入手

- 确保 lock 文件是最新的, 那么我们需要在运行一遍 `npm i` 指令, 针对 lock 的解析方案

- 打开本地网站, 针对结果的可视化显示(树形图, 父节点-重复的库, 子节点对应多个依赖)

## 开发

### 指令技术选型:

1. commander

推荐最多的, 同时也是下载量最多的, 下载量 8kw+

2. package-lock.json 

针对的 lock 文件, 默认 `npm` 及其对应的解析, 现在还有 `yarn`, `pnpm` 比较流行, 但是
一般在服务器上打包时都用使用 `npm` 指令

3. 可视化库
// TODO 可视化库 选型, 可以参考 bundle


在本文中将会使用一个 umi 项目为例

### 第一步


1. 获取配置文件, 可以单独文件, 也可在 package.json 中, 也可通过指令配置
2. 确认本地有无 package-lock.json
3. 若有则对其进行解析, 若无则运行 `npm i` v指令, 待其下载完毕后再解析 lock 文件

根据我们的思路先实现第一步的开发:

```js
const lockPath = path.resolve('package-lock.json')

async function main() {
    const isExist = fs.existsSync(lockPath)
    // 判断 lock 文件, 如果不存在则 执行 install
    if(!isExist){
        await execNpmInstall()
    }
    // 获取 lock 文件内容
    const data = fs.readFileSync(lockPath, 'utf8')
    // 解析 json
    console.log(JSON.parse(data))
}

main()
```

### 第二步

具体的解析文件

我们以一个结构来分析, 取名为结构 A:

```json5
{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    // 省略
    "react-redux": {
      "version": "7.2.8",
      "resolved": "https://registry.npmmirror.com/react-redux/-/react-redux-7.2.8.tgz",
      "integrity": "sha512-6+uDjhs3PSIclqoCk0kd6iX74gzrGc3W5zcAjbrFgEdIjRSQObdIwfx80unTkVUYvbQ95Y8Av3OvFHq1w5EOUw==",
      "requires": {
        "@babel/runtime": "^7.15.4",
        "@types/react-redux": "^7.1.20",
        "hoist-non-react-statics": "^3.3.2",
        "loose-envify": "^1.4.0",
        "prop-types": "^15.7.2",
        "react-is": "^17.0.2"
      },
      "dependencies": {
        "@babel/runtime": {
          "version": "7.17.9",
          "resolved": "https://registry.npmmirror.com/@babel/runtime/-/runtime-7.17.9.tgz",
          "integrity": "sha512-lSiBBvodq29uShpWGNbgFdKYNiFDo5/HIYsaCEY9ff4sb10x9jizo2+pRrSyF4jKZCXqgzuqBOQKbUm90gQwJg==",
          "requires": {
            "regenerator-runtime": "^0.13.4"
          }
        },
        "react-is": {
          "version": "17.0.2",
          "resolved": "https://registry.npmmirror.com/react-is/-/react-is-17.0.2.tgz",
          "integrity": "sha512-w2GsyukL62IJnlaff/nRegPQR94C/XXamvMWmSHRJ4y7Ts/4ocGRmTHvOs8PSE6pB3dWOrD/nueuU5sduBsQ4w=="
        }
      }
    }
  }
}
```

先讲解一下主要的 key 是什么意思:

- lockfileVersion  
  一个整数的版本，从1开始是本文档的版本号，在生成这个package-lock.json时使用了其语义。
  - 未提供此值, 说明是 npm v5 版本以前生成的
  - 1: npm v5和v6使用的lockfile版本。
  - 2: npm v7使用的lockfile版本，向后兼容v1的lockfiles
  - 3: npm v7使用的锁文件版本，没有向后兼容的能力。这个版本可能会在未来的npm中使用。
- dependencies  
  这是一个软件包名称到依赖对象的映射。
  - integrity
    在此位置解压的文件的sha512或sha1标准子资源完整性字符串。可用于 git 提交。
  - resolved 这是相对于注册表URL的压缩包路径。
  - requires 这是一个模块名称与版本的映射关系。这是该模块需要的所有东西的列表，不管它将被安装在哪里。
  - dependencies 和他的父元素一样, 但是是在当前包的 node_modules 中。


在这个依赖中的 `dependencies` 对应的包都会存在于此包的 node_modules 中, 比如:

`react-redux/dependencies/@babel/runtime`



## 参考

- https://docs.npmjs.com/cli/v8/configuring-npm/package-lock-json
