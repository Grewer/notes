## 前言
在前一段时间做一个需求的时候, 他有一个自定义列表的功能, 他的所有数据显示都是通过 jSON 字符串来存储,使用也是通过 JSON 解析
起先他是有数据上限的, 但是后面提高上限后就出现了卡顿等问题, 所以本文就是介绍一些方案来解决前端大量数据的渲染问题

## 方案

### innerHTML

首先是在很久很久之前的渲染方案 `innerHTML` 插入, 他是官方的 API, 性能较好

这是一个简单的 HTML 渲染例子(在试验时数据取10w级别, 扩大差异, 实际中基本会小于这个级别)
```js
    const items = new Array(100000).fill(0).map((it, index)=>{
        return `<div>item ${index}</div>`
    }).join('')
    content.innerHTML = items
```

来自谷歌的性能分析:
![](images/innerHTML.png)

可以看到阻塞时间是 1800ms 左右
在性能检测中, 总阻塞时间控制在300毫秒以内才是一个合格的状态, 这个时间还会受电脑硬件的影响

优点: 性能相对可以接受, 但数据较多时也同样有阻塞
缺点: 有注入的危险, 和框架的搭配较差, 在 dom 过多时并没有解决滚动的性能问题

### 批量插入

通过分片来插入, 假如有 10W 条数据, 我们就分成 10 次, 每次 1w 条循环插入

```js
    [...new Array(10)].forEach((_,i) => {
        requestAnimationFrame(()=>{
            [...new Array(10000)].forEach((_,index)=>{
                const item = document.createElement("div")
                item.textContent = `item ${i}${index}`
                content.append(item)
            })
        })
    })
```

经过谷歌分析:
![](images/createElement.png)

可以看到阻塞时间为 2300 毫秒, 相较 innerHTML 来说会差一点, 这是在 10w 的这个数量级, 但是在 1w 以内就相差不了多少


#### 关于 requestAnimationFrame
其中 `requestAnimationFrame` 的作用: 此方法会告诉浏览器希望执行动画并请求浏览器在下一次重绘之前调用回调函数来更新动画。

执行方式: 当执行 requestAnimationFrame(callback)的时候，不会立即调用 callback 回调函数，会将其放入回调函数队列,  
当页面可见并且动画帧请求callback回调函数列表不为空时，浏览器会定期将这些回调函数加入到浏览器 UI 线程的队列中（由系统来决定回调函数的执行时机）

总的来说就是不会阻塞其他代码的执行, 但是总的执行时间和 innerHTML 方案差不太多

优点: 不会阻塞代码的运行

缺点: 插入所花费的总时间仍旧和 innerHTML 差不太多     
    同样地, 在 dom 过多时也没有解决滚动的性能问题

### 其他原生方式

#### canvas

canvas 是专门用来绘制的一个工具, 可以用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面。

最近在著名框架 Flutter 的 Web 中就是使用 canvas 来渲染页面的

同样我们也可以使用 canvas 来渲染大量的数据

```html
<div style="max-height: 256px;max-width:256px;overflow: scroll;">
    <canvas id="canvas"></canvas>
</div>
```
```js
    let ctx = canvas.getContext('2d');
    [...new Array(100000)].map((it, index)=>{
        ctx.fillText(`item ${index}`, 0, index * 30)
    })
```

经过实际的尝试, canvas 他是有限制的,最大到 6w 左右的高度就不能再继续放大了, 也就是说在大量数据下, canvas 还是被限制住了

优点: 在渲染数量上性能很好

缺点: 想要实现列表一样的渲染, 就需要扩大 canvas, 但是这个却被限制了(在其他场景下是一种比较好的方案, 比如动画,地图等)
    并且在 canvas 中的样式难以把控

#### IntersectionObserver

>  IntersectionObserver 提供了一种异步观察目标元素与视口的交叉状态，简单地说就是能监听到某个元素是否会被我们看到，当我们看到这个元素时，可以执行一些回调函数来处理某些事务。

通过这个 api 我们可以做一些尝试, 来实现类似虚拟列表的方案

### 框架

react 中的 API , useTransition

### 虚拟列表

#### 原理

#### 最小实现方案

#### 其他库


## chrome 官方的支持

### virtual-scroller
在 Chrome dev summit 2018 上，谷歌工程经理 Gray Norton 向我们介绍 virtual-scroller，一个 Web 滚动组件，未来它可能会成为 Web 高层级 API（Layered API）的一部分。它的目标是解决长列表的性能问题，消除离屏渲染。


**但是, 经过**

### content-visibility


## 总结

## 引用

大纲:

主要讲虚拟列表
首先讲讲以前 jq 时代大量数据的引入
一个具体的例子, 具体的实现方案
讲讲 react 里面怎么实现有没有其他方法, 
CSS 的优化,一个 API, 例子的对比

看看还有没有什么优化方案

react 的 useTransition
分批插入: RAF
检测的 API:


Object.freeze(items) // 冻结对象 可以减少白屏率 ?

Canvas 渲染

CSS 属性: 
```css
.story {
  content-visibility: auto;
  contain-intrinsic-size: 1000px; /* Explained in the next section. */
    // contain-intrinsic-size: auto 300px
}
```
https://web.dev/content-visibility/


chrome 对于虚拟列表的优化 <virtual-scroller> 标签 https://github.com/WICG/virtual-scroller
https://blog.csdn.net/qq_21726139/article/details/84107936
https://chromestatus.com/feature/5673195159945216
项目停止的原因: https://github.com/WICG/virtual-scroller/issues/201

之前的不开发了, 转而开发这个: https://github.com/WICG/display-locking
