## 前言
在前一段时间做一个需求的时候, 他有一个自定义列表的功能, 他的所有数据显示都是通过 jSON 字符串来存储,使用也是通过 JSON 解析
起先他是有数据上限的, 但是后面提高上限后就出现了卡顿等问题, 所以本文就是介绍一些方案来解决前端大量数据的渲染问题

## 方案

### innerHTML

首先是在很久很久之前的渲染方案 `innerHTML` 插入, 他是官方的 API, 性能较好
```js
    const items = new Array(100000).fill(0).map((it, index)=>{
        return `<div>item ${index}</div>`
    }).join('')
    content.innerHTML = items
```

经过测试, 10w 条数据的渲染时间大概再 220ms 左右

优点: 性能较好
缺点: 有注入的危险, 和框架的搭配较差

### 批量插入

通过分片来插入, 假如有 1W 条数据, 我们就分成10 次, 每次 1 千条循环插入



再说另外的 API, 搭配 raf

### 其他原生方式

#### canvas

#### IntersectionObserver

>  IntersectionObserver 提供了一种异步观察目标元素与视口的交叉状态，简单地说就是能监听到某个元素是否会被我们看到，当我们看到这个元素时，可以执行一些回调函数来处理某些事务。

### 框架

react 中的 API , useTransition

### 虚拟列表

#### 原理

#### 最小实现方案

#### 其他库


## chrome 官方的支持

### virtual-scroller
在 Chrome dev summit 2018 上，谷歌工程经理 Gray Norton 向我们介绍 virtual-scroller，一个 Web 滚动组件，未来它可能会成为 Web 高层级 API（Layered API）的一部分。它的目标是解决长列表的性能问题，消除离屏渲染。


**但是, 经过**

### content-visibility


## 总结

## 引用

大纲:

主要讲虚拟列表
首先讲讲以前 jq 时代大量数据的引入
一个具体的例子, 具体的实现方案
讲讲 react 里面怎么实现有没有其他方法, 
CSS 的优化,一个 API, 例子的对比

看看还有没有什么优化方案

react 的 useTransition
分批插入: RAF
检测的 API:


Object.freeze(items) // 冻结对象 可以减少白屏率 ?

Canvas 渲染

CSS 属性: 
```css
.story {
  content-visibility: auto;
  contain-intrinsic-size: 1000px; /* Explained in the next section. */
    // contain-intrinsic-size: auto 300px
}
```
https://web.dev/content-visibility/


chrome 对于虚拟列表的优化 <virtual-scroller> 标签 https://github.com/WICG/virtual-scroller
https://blog.csdn.net/qq_21726139/article/details/84107936
https://chromestatus.com/feature/5673195159945216
项目停止的原因: https://github.com/WICG/virtual-scroller/issues/201

之前的不开发了, 转而开发这个: https://github.com/WICG/display-locking
