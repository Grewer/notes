## 前言
上一文讲到了图片, 这里我们就讲一个常用的图片场景: 瀑布流, 他的实现和优化

## 什么瀑布流

> 瀑布流，又称瀑布流式布局。是比较流行的一种网站页面布局，视觉表现为参差不齐的多栏布局，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。最早采用此布局的网站是 Pinterest，逐渐在国内流行开来。国内大多数清新站基本为这类风格。

更直观的展示如下图所示:

![](images/img1.png)

## 优缺点

**优点：**

1.  外表美观，更有艺术性。
2.  用户浏览时的观赏和思维不容易被打断，留存更容易。

**缺点：**

1. 用户无法了解内容总长度，对内容没有宏观掌控。
2. 用户无法了解现在所处的具体位置，不知道离终点还有多远。
3. 回溯时不容易定位到之前看到的内容。
4. 容易造成页面加载的负荷。
5. 容易造成用户浏览的疲劳，没有短暂的休息时间。


## 实现方案

### 纯 CSS 实现

这里要介绍 CSS 属性: `column`

现在常用的 `column` 属性有这些

- column-count
  将一个元素的内容分成指定数量的列。涉疫设置为具体数字, 或者`auto`
- column-fill  
  控制元素的内容在分成多列时如何平衡。有 `auto`、`balance` 两个值, 分别表示自动填充和水平分配
- column-gap  
  两列间的距离, 可设置: px, 百分比, rem
- column-rule  
  列布局中, 分割线的设置, 可以设置风格、宽度、颜色(和 border 相同的参数)
- column-span  
  列布局中横向的占用元素, 具体作用可查看[此处](https://developer.mozilla.org/en-US/docs/Web/CSS/column-span)
- column-width  
  每一列的最小宽度, 如果外部容易宽度特别小, 则会失效


另一个 CSS 属性 `columns`

他是用来设置元素的列宽和列数属性, 是由  `column-width` 和 `column-count` 两属性合并而来的简写属性

关于兼容性, 目前来看兼容性还可以, 可适应大多数情况
![](images/img2.png)


相关 CSS 属性的详情, 可点击[此处](https://developer.mozilla.org/zh-CN/docs/Web/CSS/columns)



这里再提供一个我使用 `columns` 的 demo, 预览图:
![img3.png](images/img3.png)

在线查看地址: https://grewer.github.io/JsDemo/waterfallLayout/css.html
(_可通过缩放浏览器大小来查看他的效果_)

### js 实现

通过 js 我们也可以实现瀑布流, 核心思路是:
1. 我们固定每张图片的宽度, 如 200px, 这样我们就能计算出当前屏幕中一行是多少张图片
2. 通过 1 中计算出来的数量, 我们创建高度数组, 用来存放, 每一列的高度
3. 遍历图片, 找到 2 中高度数组的最小值(默认为 0), 这样我们在对应 index 插入图片, 同时高度数组中, 也更新他的高度

#### 具体实现

第 1,2 步中的初始化和高度数组
```
    const width = 200; // 默认设置为 200px 的宽度

    const columns = Math.floor(window.innerWidth / 200) // 计算出当前页面的列
    
    const columnsHeightArr = []
    
    // mock 图片地址
    const urls = new Array(10).fill(0).map((it, index) => {
        return `https://grewer.github.io/JsDemo/waterfallLayout/imgs/img_${index}.png`
    })
```

在获取图片高度时, 我们需要注意的是, **图片未加载完成时, 是无法获取到图片高度的**

所以这里我们准备加载图片, 在图片全部加载完成后, 再进行高度的计算

```js
    let flag = 0
    
    const getImg = (url) => {
        let img = new Image();
        img.src = url;
        const imgCallback = () => {
            flag++;
            if (flag === urls.length) {
                handler();
            }
        }
        
        // 是否缓存
        if (img.complete) {
            imgCallback()
        } else {
            img.onload = imgCallback
        }
    }
```

在图片全部加载完毕之后, 进入 `handler` 函数, 来正式操作图片:

```js
    // 添加图片到容器中, 通过 position: absolute 的方案来实现
    const appendImages = (url, position, top) => {
        const img = document.createElement('img');
        img.src = url;
        img.style.left = (position * width) + 'px';
        img.style.top = top + 'px';
        container.appendChild(img)
        return img
    }
    
    // 获取高度数组中的最小高度
    const getMin = (arr) => {
        let minHeight = arr[0];
        let index = 0
        for (let i = 1; i < arr.length; i++) {
            if (arr[i] < minHeight) {
                minHeight = arr[i]
                index = i
            }
        }
        return {index, minHeight}
    }
    const insertImages = () => {
        for (let i = 0; i < urls.length; i++) {
            // 判断是否小于一行, 这样我们就能直接加入了
            if (columnsHeightArr.length < columns) {
                const img = appendImages(urls[i], i, 0)
                columnsHeightArr[i] = img.offsetHeight;
            } else {
                const {index, minHeight} = getMin(columnsHeightArr)
                const img = appendImages(urls[i], index, minHeight);
                columnsHeightArr[index] = columnsHeightArr[index] + img.offsetHeight;
            }
        }
    }
    
```

最后的实现效果:


在线 demo 查看: 

## 总结


## 引用

- https://www.zhihu.com/question/20005422/answer/287568035
- https://developer.mozilla.org/zh-CN/docs/Web/CSS/columns