## 前言

前端基建里最重要的事情之一就是监控，性能，报错，白屏等等，而今天要说的就是白屏的监控。
前端白屏是影响用户体验的常见问题，通常有资源加载失败、JS 执行错误、渲染阻塞、框架异常等原因。
今天就以**页面生命周期、错误捕获、性能指标、框架特性**等维度来描述怎么监控。

##  关键节点判断

#### 核心原理

不管是传统框架、界面、还是现代浏览器框架，都会有一个容器节点、关键节点，例如根节点，header节点，logo 节点等等，我们要做的就是在页面加载完成之后判断它是否存在即可

### 关键检测维度

1. **元素是否存在**：`document.querySelector(selector)` 是否返回非 null 值（排除因 HTML 结构错误导致的元素缺失）。
2. **是否有实际内容**：元素的 `textContent.trim()` 不为空（排除空标签），或 `childNodes.length > 0`（存在子元素）。
3. **是否可见**：
    - 布局可见性：`offsetHeight > 0` 且 `offsetWidth > 0`（排除 `display: none` 或内容被完全遮挡）。
    - 样式可见性：`getComputedStyle(element).visibility !== 'hidden'` 且 `opacity > 0`（排除透明或隐藏样式）。

```js
function checkCriticalElement(selector, options = {}) {
  const { 
    timeout = 5000,   // 超时阈值（默认5秒）
    interval = 500,   // 检测间隔（默认500ms，平衡精度与性能）
    onWhiteScreen = () => {} // 白屏回调
  } = options;

  const startTime = Date.now();
  const timer = setInterval(() => {
    const now = Date.now();
    // 1. 超时判断：超过阈值仍未检测到有效元素，触发白屏
    if (now - startTime > timeout) {
      clearInterval(timer);
      onWhiteScreen({
        type: 'critical_element_timeout',
        selector,
        duration: now - startTime,
        reason: '元素未在规定时间内加载完成'
      });
      return;
    }

    // 2. 元素存在性检测
    const element = document.querySelector(selector);
    if (!element) return; // 元素未加载，继续等待

    // 3. 内容有效性检测
    const hasContent = element.textContent.trim() !== '' || element.childNodes.length > 0;
    if (!hasContent) return; // 元素存在但无内容，继续等待

    // 4. 可见性检测
    const computedStyle = getComputedStyle(element);
    const isVisible = 
      element.offsetHeight > 0 && 
      element.offsetWidth > 0 && 
      computedStyle.visibility !== 'hidden' && 
      computedStyle.opacity > 0;

    if (isVisible) {
      clearInterval(timer); // 所有条件满足，停止检测
    }
  }, interval);
}
```

### 触发时机

- **首屏加载**：在 `DOMContentLoaded` 事件后启动检测
- **单页应用（SPA）路由切换**：在路由钩子（如 Vue 的 `router.afterEach`、React 的 `useEffect` 监听路由变化）中触发，检测新页面的关键元素。
- **动态内容加载**：对于异步渲染的内容（如列表、表单），在接口请求完成后启动检测。

## 错误捕获

### 1. JS 运行时错误捕获

##### 同步错误（`window.onerror`）

- **触发场景**：直接执行的 JS 代码抛出未捕获的错误（如 `undefined.xxx`、语法错误）。
- **参数详解**：
    - `message`：错误信息（字符串）。
    - `source`：错误发生的脚本 URL。
    - `lineno`/`colno`：错误行号 / 列号。
    - `error`：错误对象（含 `stack` 调用栈，最关键的排查依据）。

```javascript
window.onerror = function(message, source, lineno, colno, error) {
  // 过滤非关键错误（如第三方脚本的非阻塞错误）
  const isCritical = source.includes('/app.') || source.includes('/main.'); // 仅关注核心脚本
  if (isCritical) {
    reportError({
      type: 'js_runtime_error',
      message: error?.message || message,
      stack: error?.stack || `at ${source}:${lineno}:${colno}`,
      time: Date.now()
    });
  }
  return true;
};
```

##### 异步错误（`window.onunhandledrejection`）

- **触发场景**：Promise 链式调用中未通过 `.catch()` 处理的错误（如接口请求失败、`async/await` 未用 `try/catch`）。

```javascript
window.onunhandledrejection = function(event) {
  const reason = event.reason;
  reportError({
    type: 'unhandled_promise',
    message: reason?.message || String(reason),
    stack: reason?.stack,
    time: Date.now()
  });
  event.preventDefault(); // 阻止浏览器默认警告
};
```

#### 2. 资源加载错误捕获

##### 触发场景

- 脚本（`<script>`）加载失败（404/500 状态、跨域限制）。
- 样式表（`<link rel="stylesheet">`）加载失败（导致页面无样式，视觉上白屏）。

```javascript
window.addEventListener('error', (event) => {
  const target = event.target;
  // 仅处理资源加载错误
  if (!['SCRIPT', 'LINK', 'IMG'].includes(target.tagName)) return;

  // 判断是否为关键资源（根据业务定义）
  const isCritical = 
    (target.tagName === 'SCRIPT' && target.src.includes('/vue.runtime') || target.src.includes('/app.')) ||
    (target.tagName === 'LINK' && target.rel === 'stylesheet' && target.href.includes('/main.css'));

  if (isCritical) {
    reportError({
      type: 'resource_load_error',
      tag: target.tagName,
      url: target.src || target.href,
      status: target.error?.status || 'unknown', // 部分浏览器返回HTTP状态码
      time: Date.now()
    });
  }
}, true); // 捕获阶段监听
```

快速定位因代码错误或资源缺失导致的白屏（如框架脚本加载失败直接导致无法渲染）。但是并非所有错误都会导致白屏（如非首屏脚本错误），需通过 “关键资源 / 脚本” 过滤。

## 基于性能指标的检测


## 框架钩子监听


## 像素检测




## 小结

单一方法难以覆盖所有白屏场景，需结合多种手段形成闭环：

| 方法类型   | 核心手段                                 | 适用场景         |
| ------ | ------------------------------------ | ------------ |
| 关键元素检测 | 定时检查 DOM 存在性和内容                      | 首屏加载、路由切换后白屏 |
| 错误捕获   | JS 错误、资源加载错误                         | 代码异常导致的白屏    |
| 性能指标监控 | FCP、LCP、DOM 就绪时间                     | 渲染阻塞导致的白屏    |
| 框架异常监听 | Vue errorHandler、React ErrorBoundary | 组件渲染错误导致的白屏  |
| 视觉检测   | 内容高度 / 像素分析                          | 样式错乱导致的白屏    |